â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                    TÃ“M Táº®T LOGIC CÃC LUá»’NG NGHIá»†P Vá»¤ CHÃNH                   â•‘
â•‘                  Há»† THá»NG QUáº¢N LÃ Váº¬N CHUYá»‚N - TRUCKIE                       â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

================================================================================
1. LOGIC Äá»€ XUáº¤T XE HÃ€NG (BINPACKER ALGORITHM)
================================================================================

ğŸ“Œ Má»¤C ÄÃCH:
   Tá»± Ä‘á»™ng phÃ¢n bá»• cÃ¡c kiá»‡n hÃ ng vÃ o xe phÃ¹ há»£p, tá»‘i Æ°u hÃ³a sá»‘ lÆ°á»£ng xe.

ğŸ“‹ CÆ  CHáº¾ HOáº T Äá»˜NG:

   BÆ¯á»šC 1: CHUáº¨N Bá»Š Dá»® LIá»†U
   â€¢ Láº¥y OrderDetail tá»« Order, SizeRule tá»« nhá» â†’ lá»›n
   â€¢ Validate: kiá»‡n hÃ ng khÃ´ng vÆ°á»£t xe lá»›n nháº¥t

   BÆ¯á»šC 2: CHUYá»‚N Äá»”I Dá»® LIá»†U
   â€¢ OrderDetail â†’ BoxItem (kÃ­ch thÆ°á»›c, trá»ng lÆ°á»£ng)

   BÆ¯á»šC 3: Sáº®P Xáº¾P KIá»†N HÃ€NG
   â€¢ Æ¯u tiÃªn: Density > Volume > Weight > Dimension
   â€¢ HÃ ng náº·ng Ä‘áº·c Ä‘áº·t trÆ°á»›c, kiá»‡n lá»›n Ä‘áº·t trÆ°á»›c kiá»‡n nhá»

   BÆ¯á»šC 4: THUáº¬T TOÃN Äáº¶T HÃ€NG (3D BIN PACKING)
   
   // BinPacker.java
   public List<ContainerState> pack(List<BoxItem> items, List<SizeRuleEntity> rules) {
     // Chiáº¿n lÆ°á»£c 1: Äáº·t vÃ o xe hiá»‡n cÃ³
     for (BoxItem item : sortedItems) {
       if (tryToPackInExistingContainers(item)) continue;
       
       // Chiáº¿n lÆ°á»£c 2: NÃ¢ng cáº¥p xe
       if (tryToUpgradeContainerAndPack(item)) continue;
       
       // Chiáº¿n lÆ°á»£c 3: Má»Ÿ xe má»›i
       openNewContainerAndPack(item);
     }
   }

ğŸ” ÄIá»‚M Äáº¶C BIá»†T:
   â€¢ Cho phÃ©p xoay kiá»‡n hÃ ng (6 hÆ°á»›ng)
   â€¢ TÃ­nh FitScore = (dimensionÃ—0.3 + weightÃ—0.35 + volumeÃ—0.35)
   â€¢ Bonus +0.2 náº¿u 0.4 â‰¤ score â‰¤ 0.7 (sweet spot)


================================================================================
2. LOGIC TÃNH TIá»€N Há»¢P Äá»’NG (PRICING CALCULATION)
================================================================================

ğŸ“Œ Má»¤C ÄÃCH:
   TÃ­nh chi phÃ­ váº­n chuyá»ƒn dá»±a trÃªn khoáº£ng cÃ¡ch, loáº¡i xe, trá»ng lÆ°á»£ng.

ğŸ“‹ CÆ  CHáº¾ HOáº T Äá»˜NG:

   KHÃI NIá»†M QUAN TRá»ŒNG:
   â€¢ totalValue: giÃ¡ tá»± Ä‘á»™ng tá»« há»‡ thá»‘ng
   â€¢ adjustedValue: giÃ¡ Staff Ä‘iá»u chá»‰nh
   
   // ContractServiceImpl.java
   public BigDecimal getEffectiveContractValue(ContractEntity contract) {
     return contract.getAdjustedValue().compareTo(BigDecimal.ZERO) > 0 
       ? contract.getAdjustedValue() 
       : contract.getTotalValue();
   }

   CÃ”NG THá»¨C TÃNH GIÃ:
   basePrice = basingPrice.pricePerKm Ã— actualDistance
   insuranceSurcharge = SUM(declaredValue) Ã— (category=NORMAL ? 0.08% : 0.15%)
   fragileSurcharge = category=FRAGILE ? basePrice Ã— 20% : 0
   overweightSurcharge = basePrice Ã— overweightRatio Ã— 50%
   totalPrice = basePrice + insuranceSurcharge + fragileSurcharge + overweightSurcharge


================================================================================
3. LOGIC PHÃ‚N CÃ”NG XE VÃ€ TÃ€I Xáº¾ (DRIVER ASSIGNMENT)
================================================================================

ğŸ“Œ Má»¤C ÄÃCH:
   Gá»£i Ã½ xe vÃ  tÃ i xáº¿ phÃ¹ há»£p nháº¥t cho tá»«ng chuyáº¿n hÃ ng.

ğŸ“‹ CÆ  CHáº¾ HOáº T Äá»˜NG:

   BÆ¯á»šC 1: Lá»ŒC XE
   â€¢ Äiá»u kiá»‡n: ACTIVE, Ä‘Ãºng vehicleType, khÃ´ng bá»‹ exclude, khÃ´ng reserved,
     Ä‘Äƒng kiá»ƒm/báº£o hiá»ƒm cÃ²n háº¡n, khÃ´ng cÃ³ active assignment

   BÆ¯á»šC 2: Lá»ŒC TÃ€I Xáº¾
   â€¢ Äiá»u kiá»‡n: ACTIVE, licenseClass phÃ¹ há»£p, khÃ´ng active assignment,
     khÃ´ng bá»‹ exclude, khÃ´ng cÃ³ assignment cÃ¹ng ngÃ y

   BÆ¯á»šC 3: CHáº¤M ÄIá»‚M TÃ€I Xáº¾ (Ä‘iá»ƒm tháº¥p = Æ°u tiÃªn cao)
   
   // VehicleAssignmentServiceImpl.java
   private int calculateDriverScore(DriverEntity driver, VehicleEntity vehicle) {
     int score = 0;
     
     // LICENSE CLASS: B2=0, C=100
     score += driver.getLicenseClass().equals("B2") ? 0 : 100;
     
     // FAMILIARITY: -600 to 0 Ä‘iá»ƒm
     if (hasDriverDrivenVehicleBefore(driver.getId(), vehicle.getId())) {
       score -= 500;  // BIG BONUS
       if (wasMainDriverInLastAssignment(driver.getId(), vehicle.getId())) {
         score -= 100;  // Extra bonus
       }
     }
     
     // RECENT ACTIVITY: +20 Ä‘iá»ƒm/chuyáº¿n (30 ngÃ y)
     score += countRecentActivities(driver.getId(), 30) * 20;
     
     // WORKLOAD BALANCE, VIOLATIONS, TIME SINCE LAST ASSIGNMENT...
     
     return score;
   }


================================================================================
4. LOGIC TÃNH CÆ¯á»šC TRáº¢ HÃ€NG (RETURN SHIPPING COST)
================================================================================

ğŸ“Œ Má»¤C ÄÃCH:
   TÃ­nh chi phÃ­ tráº£ hÃ ng khi ngÆ°á»i nháº­n tá»« chá»‘i.

ğŸ“‹ CÆ  CHáº¾ HOáº T Äá»˜NG:

   BÆ¯á»šC 1: XÃC Äá»ŠNH KIá»†N TRáº¢
   â€¢ Staff chá»n OrderDetail bá»‹ tá»« chá»‘i
   â€¢ Link vÃ o Issue.orderDetails

   BÆ¯á»šC 2: TÃNH KHOáº¢NG CÃCH
   â€¢ Máº·c Ä‘á»‹nh: deliveryAddress â†’ pickupAddress
   â€¢ Hoáº·c dÃ¹ng actualDistanceKm tá»« FE (náº¿u cÃ³ waypoints)

   BÆ¯á»šC 3-4: XÃC Äá»ŠNH LOáº I XE VÃ€ TÃNH GIÃ
   
   // IssueServiceImpl.java
   public ReturnShippingFeeResponse calculateReturnShippingFee(UUID issueId) {
     // Láº¥y khoáº£ng cÃ¡ch
     double distanceKm = actualDistanceKm != null 
       ? actualDistanceKm 
       : calculateDistance(deliveryAddress, pickupAddress);
     
     // TÃ­nh giÃ¡ cÆ°á»›c
     PriceCalculationResponse priceResponse = contractService.calculateTotalPrice(
         contract, distanceKm, vehicleCountMap
     );
     
     // Äiá»u chá»‰nh giÃ¡ náº¿u cáº§n
     BigDecimal finalFee = issue.getAdjustedReturnFee() != null 
       ? issue.getAdjustedReturnFee() 
       : priceResponse.getTotalPrice();
       
     return buildReturnShippingFeeResponse(distanceKm, priceResponse, finalFee);
   }


================================================================================
5. NGHIá»†P Vá»¤ Xá»¬ LÃ Bá»’I THÆ¯á»œNG (COMPENSATION)
================================================================================

ğŸ“Œ Má»¤C ÄÃCH:
   Xá»­ lÃ½ bá»“i thÆ°á»ng khi hÃ ng hÃ³a bá»‹ hÆ° há»ng/máº¥t mÃ¡t.

ğŸ“‹ CÆ  CHáº¾ HOáº T Äá»˜NG:

   BÆ¯á»šC 1: STAFF THáº¨M Äá»ŠNH
   â€¢ hasDocuments, documentValue, assessmentRatePercent
   â€¢ PhÃ¡t hiá»‡n gian láº­n: fraudDetected â†’ ban account

   BÆ¯á»šC 2: TÃNH Bá»’I THÆ¯á»œNG
   
   // CompensationServiceImpl.java
   private CompensationBreakdown calculateDamageCompensationBreakdown(
       CompensationAssessmentRequest request, 
       OrderDetailEntity orderDetail) {
     
     // XÃ¡c Ä‘á»‹nh giÃ¡ trá»‹ thá»±c táº¿
     BigDecimal actualValue = determineActualValue(
         request.isHasDocuments(), 
         request.getDocumentValue(),
         request.getEstimatedMarketValue(),
         orderDetail.getDeclaredValue()
     );
     
     // TÃ­nh tá»· lá»‡ trá»ng lÆ°á»£ng vÃ  hoÃ n cÆ°á»›c
     double weightRatio = orderDetail.getWeightTons() / order.getTotalWeightTons();
     BigDecimal freightRefund = calculateFreightRefund(
         order.getContract().getEffectiveValue(), 
         weightRatio, 
         request.getAssessmentRatePercent()
     );
     
     // TÃ­nh giÃ¡ trá»‹ máº¥t mÃ¡t
     BigDecimal valueLoss = actualValue.multiply(
         BigDecimal.valueOf(request.getAssessmentRatePercent() / 100.0)
     );
     
     // Giá»›i háº¡n phÃ¡p luáº­t: 10Ã— cÆ°á»›c
     BigDecimal legalLimit = order.getContract().getEffectiveValue().multiply(BigDecimal.TEN);
     
     // TÃ­nh bá»“i thÆ°á»ng theo case
     if (orderDetail.isHasInsurance() && request.isHasDocuments()) {
       // CASE 1: CÃ³ BH + CÃ³ CT â†’ KhÃ´ng giá»›i háº¡n
       goodsCompensation = valueLoss.min(orderDetail.getDeclaredValue());
     } else {
       // CASE 2, 3, 4: Ãp dá»¥ng giá»›i háº¡n 10Ã—
       goodsCompensation = valueLoss.min(legalLimit);
     }
     
     // Tá»•ng bá»“i thÆ°á»ng
     BigDecimal totalCompensation = goodsCompensation.add(freightRefund);
     
     // Fix CASE 2: Cap tá»•ng á»Ÿ legal limit
     if (orderDetail.isHasInsurance() && !request.isHasDocuments()) {
       totalCompensation = totalCompensation.min(legalLimit);
     }
     
     return buildCompensationBreakdown(...);
   }


================================================================================
6. LOGIC CHECK OFF ROUTE (PHÃT HIá»†N Lá»†CH TUYáº¾N)
================================================================================

ğŸ“Œ Má»¤C ÄÃCH:
   GiÃ¡m sÃ¡t GPS, phÃ¡t hiá»‡n tÃ i xáº¿ lá»‡ch tuyáº¿n.

ğŸ“‹ CÆ  CHáº¾ HOáº T Äá»˜NG:

   BÆ¯á»šC 1: Xá»¬ LÃ Vá»Š TRÃ GPS
   
   // OffRouteDetectionServiceImpl.java
   public Double processLocationUpdate(UUID vehicleAssignmentId, Double lat, Double lng) {
     // TÃ¬m journey active
     JourneyEntity journey = journeyService.findLatestActiveJourney(vehicleAssignmentId);
     
     // TÃ­nh khoáº£ng cÃ¡ch Ä‘áº¿n route
     Double distanceToRoute = calculateDistanceToRoute(lat, lng, journey.getSegments());
     
     // Xá»­ lÃ½ off-route náº¿u vÆ°á»£t ngÆ°á»¡ng
     if (distanceToRoute > MAX_DISTANCE_ON_ROUTE) { // 500m
       handleOffRoute(assignment, lat, lng, distanceToRoute);
     } else {
       handleBackOnRoute(vehicleAssignmentId);
     }
     
     return distanceToRoute;
   }

   BÆ¯á»šC 2: Há»† THá»NG Cáº¢NH BÃO PHÃ‚N Cáº¤P
   
   // OffRouteDetectionServiceImpl.java
   private void checkWarningThresholds(OffRouteEventEntity event) {
     int durationMinutes = calculateMinutesSince(event.getOffRouteStartTime());
     int minutesSinceLastContact = event.getContactedAt() != null 
       ? calculateMinutesSince(event.getContactedAt()) 
       : Integer.MAX_VALUE;
     
     // YELLOW WARNING (5 phÃºt)
     if (event.getWarningStatus() == NONE && durationMinutes >= 5) {
       event.setWarningStatus(YELLOW_SENT);
       event.setYellowWarningSentAt(LocalDateTime.now());
       sendWarningToStaff(event, "YELLOW");
     }
     
     // RED WARNING (10 phÃºt)
     if (event.getWarningStatus() == YELLOW_SENT) {
       boolean shouldSendRed = event.getContactedAt() == null
         ? durationMinutes >= 10
         : minutesSinceLastContact >= 10;
         
       if (shouldSendRed) {
         event.setWarningStatus(RED_SENT);
         event.setRedWarningSentAt(LocalDateTime.now());
         sendWarningToStaff(event, "RED");
       }
     }
   }


================================================================================
7. LOGIC TÃNH NHIÃŠN LIá»†U TIÃŠU THá»¤ (FUEL CONSUMPTION)
================================================================================

ğŸ“Œ Má»¤C ÄÃCH:
   TÃ­nh nhiÃªn liá»‡u tiÃªu thá»¥ thá»±c táº¿ sau má»—i chuyáº¿n hÃ ng.

ğŸ“‹ CÆ  CHáº¾ HOáº T Äá»˜NG:

   BÆ¯á»šC 1: PHÆ¯Æ NG PHÃP ODOMETER (Æ¯U TIÃŠN)
   
   // VehicleFuelConsumptionServiceImpl.java
   public VehicleFuelConsumptionRecord calculateFuelConsumptionByOdometer(UUID assignmentId) {
     // Láº¥y odometer records
     OdometerRecord beforeRecord = findByType(assignmentId, "BEFORE_TRIP");
     OdometerRecord afterRecord = findByType(assignmentId, "AFTER_TRIP");
     
     // TÃ­nh khoáº£ng cÃ¡ch
     double startOdometer = beforeRecord.getOdometerReading();
     double endOdometer = returnRecord != null 
       ? returnRecord.getOdometerReading() 
       : afterRecord.getOdometerReading();
     double totalDistanceKm = endOdometer - startOdometer;
     
     // Láº¥y base fuel rate
     double baseFuelRate = vehicle.getVehicleType().getFuelConsumptionRate();
     
     // TÃ­nh nhiÃªn liá»‡u vá»›i load factor
     double deliveryDistance = journey.getTotalDistanceKm();
     double returnDistance = totalDistanceKm - deliveryDistance;
     
     final double FULL_LOAD_FACTOR = 1.2;   // TÄƒng 20% khi cÃ³ hÃ ng
     final double EMPTY_LOAD_FACTOR = 0.8;  // Giáº£m 20% khi khÃ´ng hÃ ng
     
     double fuelForDelivery = (deliveryDistance / 100) * baseFuelRate * FULL_LOAD_FACTOR;
     double fuelForReturn = (returnDistance / 100) * baseFuelRate * EMPTY_LOAD_FACTOR;
     
     double totalFuelConsumed = fuelForDelivery + fuelForReturn;
     
     return createFuelConsumptionRecord(...);
   }

   BÆ¯á»šC 2: PHÆ¯Æ NG PHÃP SEGMENT (FALLBACK)
   
   // VehicleFuelConsumptionServiceImpl.java
   public VehicleFuelConsumptionRecord calculateFuelConsumptionBySegments(UUID assignmentId) {
     List<JourneySegmentEntity> segments = journey.getSegments();
     double baseFuelRate = vehicle.getVehicleType().getFuelConsumptionRate();
     
     double totalFuel = 0;
     double totalDistance = 0;
     
     for (JourneySegmentEntity segment : segments) {
       double segmentDistance = segment.getDistanceKm();
       
       // XÃ¡c Ä‘á»‹nh load factor theo segment type
       double loadFactor = segment.getType().equals("PICKUP") || segment.getType().equals("DELIVERY")
         ? 1.2  // CÃ³ hÃ ng
         : 0.8; // KhÃ´ng hÃ ng
       
       double segmentFuel = (segmentDistance / 100) * baseFuelRate * loadFactor;
       totalFuel += segmentFuel;
       totalDistance += segmentDistance;
     }
     
     return createFuelConsumptionRecord(...);
   }


â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                              Káº¾T LUáº¬N                                         â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Há»‡ thá»‘ng Truckie triá»ƒn khai 7 luá»“ng nghiá»‡p vá»¥ phá»©c táº¡p vá»›i logic cháº·t cháº½:

1. BinPacker: Tá»‘i Æ°u 3D bin packing vá»›i 3 chiáº¿n lÆ°á»£c thÃ´ng minh
2. Pricing: CÃ´ng thá»©c tÃ­nh giÃ¡ linh hoáº¡t vá»›i nhiá»u phá»¥ phÃ­
3. Driver Assignment: Cháº¥m Ä‘iá»ƒm Ä‘a yáº¿u tá»‘, cÃ¢n báº±ng workload
4. Return Shipping: TÃ­nh cÆ°á»›c tráº£ hÃ ng chÃ­nh xÃ¡c theo tá»«ng kiá»‡n
5. Compensation: 4 cases bá»“i thÆ°á»ng rÃµ rÃ ng, phÃ¡t hiá»‡n gian láº­n
6. Off-route: 3-tier warning, grace period, auto issue creation
7. Fuel Consumption: Odometer-first vá»›i segment-based fallback
